<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>OCR ‚Üí Gemini ‚Üí Telegram</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <h2>üì∑ OCR ‚Üí Gemini ‚Üí Telegram Bot</h2>

  <video id="video" autoplay playsinline style="width:100%;border:1px solid #000;"></video>

  <!-- Zoom control buttons -->
  <div>
    <button id="zoomOut">‚ûñ Zoom Out</button>
    <button id="zoomIn">‚ûï Zoom In</button>
  </div>

  <!-- Camera switch button -->
  <div>
    <button id="switchCamera">üîÑ Switch Camera</button>
  </div>

  <pre id="log"></pre>

  <script>
    const GEMINI_API_KEY = "AIzaSyD6tSpHZBioYNcIPsJ2BLf2hhniyIFYb9s";
    const TELEGRAM_BOT_TOKEN = "8241568142:AAG-mtJeGRL-YzCd_M_r3F1FbteDLeOrVO8";
    const TELEGRAM_CHAT_ID = "7225122599";

    const video = document.getElementById("video");
    const log = document.getElementById("log");
    const switchBtn = document.getElementById("switchCamera");
    const zoomInBtn = document.getElementById("zoomIn");
    const zoomOutBtn = document.getElementById("zoomOut");

    let videoTrack;
    let currentStream;
    let currentFacingMode = "environment"; // or "user"
    let currentZoom = 1;
    let minZoom = 1;
    let maxZoom = 1;
    let zoomStep = 0.1;

    async function startCamera() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { exact: currentFacingMode } }
        });

        currentStream = stream;
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks()[0];

        const capabilities = videoTrack.getCapabilities();
        if (capabilities.zoom) {
          minZoom = capabilities.zoom.min;
          maxZoom = capabilities.zoom.max;
          zoomStep = capabilities.zoom.step || 0.1;
          currentZoom = minZoom;

          applyZoom(currentZoom);
        }
      } catch (err) {
        log.innerText = "Camera error: " + err;
      }
    }

    function applyZoom(zoomLevel) {
      if (!videoTrack) return;
      videoTrack.applyConstraints({ advanced: [{ zoom: zoomLevel }] });
    }

    zoomInBtn.addEventListener("click", () => {
      if (!videoTrack) return;
      currentZoom = Math.min(currentZoom + zoomStep, maxZoom);
      applyZoom(currentZoom);
    });

    zoomOutBtn.addEventListener("click", () => {
      if (!videoTrack) return;
      currentZoom = Math.max(currentZoom - zoomStep, minZoom);
      applyZoom(currentZoom);
    });

    switchBtn.addEventListener("click", () => {
      currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
      startCamera();
    });

    function captureFrame() {
      const canvas = document.createElement("canvas");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(video, 0, 0);
      return canvas;
    }

    async function processFrame() {
      const canvas = captureFrame();
      log.innerText = "‚è≥ Extracting text...";

      const result = await Tesseract.recognize(canvas, 'eng');
      const extractedText = result.data.text.trim();
      log.innerText = "üìñ OCR Text: " + extractedText;

      if (!extractedText) {
        log.innerText += "\n‚ö†Ô∏è No text found, skipping...";
        return;
      }

      const geminiRes = await fetch(
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=" + GEMINI_API_KEY,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [{ parts: [{ text: "Answer this: " + extractedText }]}]
          })
        }
      );

      const geminiData = await geminiRes.json();
      const answer = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text || "‚ö†Ô∏è No response";

      log.innerText += "\nü§ñ Gemini: " + answer;

      await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chat_id: TELEGRAM_CHAT_ID, text: answer })
      });

      log.innerText += "\nüì© Sent to Telegram!";
    }

    startCamera();
    setInterval(processFrame, 30000);
  </script>
</body>
</html>
