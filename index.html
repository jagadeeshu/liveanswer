<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>OCR ‚Üí Gemini ‚Üí Telegram</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <h2>üì∑ OCR ‚Üí Gemini ‚Üí Telegram Bot</h2>
  <video id="video" autoplay playsinline style="width:100%;border:1px solid #000;"></video>
  
  <!-- Zoom control -->
  <div>
    <label for="zoom">üîç Zoom:</label>
    <input id="zoom" type="range" min="1" max="5" step="0.1" value="1">
  </div>

  <pre id="log"></pre>

  <script>
    // üîë Config
    const GEMINI_API_KEY = "AIzaSyD6tSpHZBioYNcIPsJ2BLf2hhniyIFYb9s";
    const TELEGRAM_BOT_TOKEN = "8241568142:AAG-mtJeGRL-YzCd_M_r3F1FbteDLeOrVO8";
    const TELEGRAM_CHAT_ID = "7225122599";

    const video = document.getElementById("video");
    const log = document.getElementById("log");
    const zoomSlider = document.getElementById("zoom");

    let videoTrack;

    // Start camera (prefer back camera)
    navigator.mediaDevices.getUserMedia({
      video: { facingMode: { exact: "environment" } }
    })
    .then(stream => {
      video.srcObject = stream;
      videoTrack = stream.getVideoTracks()[0];

      // Check if zoom supported
      const capabilities = videoTrack.getCapabilities();
      if (capabilities.zoom) {
        zoomSlider.min = capabilities.zoom.min;
        zoomSlider.max = capabilities.zoom.max;
        zoomSlider.step = capabilities.zoom.step || 0.1;
        zoomSlider.value = capabilities.zoom.min;
        zoomSlider.style.display = "block";
      } else {
        zoomSlider.style.display = "none"; // hide if not supported
      }
    })
    .catch(err => log.innerText = "Camera error: " + err);

    // Zoom handler
    zoomSlider.addEventListener("input", () => {
      if (!videoTrack) return;
      const constraints = { advanced: [{ zoom: zoomSlider.value }] };
      videoTrack.applyConstraints(constraints);
    });

    // Take snapshot from video
    function captureFrame() {
      const canvas = document.createElement("canvas");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(video, 0, 0);
      return canvas;
    }

    // OCR ‚Üí Gemini ‚Üí Telegram
    async function processFrame() {
      const canvas = captureFrame();
      log.innerText = "‚è≥ Extracting text...";

      // OCR with Tesseract.js
      const result = await Tesseract.recognize(canvas, 'eng');
      const extractedText = result.data.text.trim();
      log.innerText = "üìñ OCR Text: " + extractedText;

      if (!extractedText) {
        log.innerText += "\n‚ö†Ô∏è No text found, skipping...";
        return;
      }

      // Send to Gemini
      const geminiRes = await fetch(
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=" + GEMINI_API_KEY,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [{ parts: [{ text: "Answer this: " + extractedText }]}]
          })
        }
      );
      const geminiData = await geminiRes.json();
      const answer = geminiData?.candidates?.[0]?.content?.parts?.[0]?.text || "‚ö†Ô∏è No response";

      log.innerText += "\nü§ñ Gemini: " + answer;

      // Send to Telegram
      await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chat_id: TELEGRAM_CHAT_ID, text: answer })
      });

      log.innerText += "\nüì© Sent to Telegram!";
    }

    // Run every 30 seconds
    setInterval(processFrame, 30000);
  </script>
</body>
</html>
